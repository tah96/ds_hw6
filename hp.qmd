---
title: "Hodge Podge"
format: html
editor: visual
---

## Libraries

Before starting anything, we will read in our necessary libraries

```{r}
library(tidyverse)
library(jsonlite)
```

## Task 2: Writing R Functions

To get some practice writing some advanced R functions using our new libraries, we will start by writing a function to compute Root Mean Square Error (RMSE).

We want to pass a vector of responses and predictions. We also want to give the user an option to pass additional arguments in our function that get passed to the mean function to instruct how to deal with NA values

```{r}
getRMSE <- function(responses,predictions,...){
  if (!is.vector(responses) | !is.vector(predictions)) {
    stop("Both your response and prediction inputs must be vectors")
  }
  meanError <- mean((responses-predictions)^2,...)
  squareMeanError <- sqrt(meanError)
  return(squareMeanError)
}
```

Lets create some response and prediction variables.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Using this data, lets tests or `getRMSE` function to make sure it works without error.

```{r}
getRMSE(responses = resp,predictions = pred)
```
We need replace two values in our response vector with `NA_real_` to ensure we can specify behavior to deal with these and not. Lets replaced the 31st and 52nd values with `NA_real_`

```{r}
resp[31] <- NA_real_
resp[52] <- NA_real_
```

Lets test the function specifying how to deal with these NAs and without specifying how to deal with these.

We see when no behavior is specified we get an error, but when we specify `na.rm=TRUE` our function will pass this to the localized mean function and remove NAs

```{r}
## No behavior specified
getRMSE(resp,pred)

## Behavior specified.
getRMSE(resp,pred,na.rm=TRUE)
```
In addition to RMSE, we want to look at MAE or the Mean Absolute Error. Lets create a function for this and follow similar behaviors to getRMSE

```{r}
getMAE <- function(responses,predictions,...){
  if (!is.vector(responses) | !is.vector(predictions)) {
    stop("Both your response and prediction inputs must be vectors")
  }
  absMeanError <- mean(abs(responses-predictions),...)
  return(absMeanError)
}
```

Reset our responses and predictions...

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Lets test the function. Success!

```{r}
getMAE(resp,pred)
```
We need replace two values in our response vector with `NA_real_` to ensure we can specify behavior to deal with these and not. Lets replaced the 31st and 52nd values with `NA_real_`

```{r}
resp[31] <- NA_real_
resp[52] <- NA_real_
```

Lets test the function specifying how to deal with these NAs and without specifying how to deal with these.

We see when no behavior is specified we get an error, but when we specify `na.rm=TRUE` our function will pass this to the localized mean function and remove NAs

```{r}
## No behavior specified
getMAE(resp,pred)

## Behavior specified.
getMAE(resp,pred,na.rm=TRUE)
```
Let’s create a wrapper function that can be used to get either or both metrics returned with a single function call with appropriate names. We'll perform checks, default behaviors and flexibility features to allow for other metrics that aren't RMSE or MAE

The function should check that two numeric (atomic) vectors have been passed (consider is.vector(),
is.atomic(), and is.numeric()). If not, a message should print and the function should exit.
• The function should return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.

```{r}
wrapperFunc <- function(func = list("getRMSE","getMAE"),responses,predictions,...){
  if ((!is.vector(responses) | !is.vector(predictions)) | 
      (!is.atomic(responses) | !is.atomic(predictions)) |
      (!is.numeric(responses) | !is.numeric(predictions))
      ){
    stop("Both your response and prediction inputs must be atomic numeric vectors")
  }
  resultList <- list()
  for(f in func){
    retrieveFunc <- get(f)
    funcVal <- retrieveFunc(responses,predictions,...)
    resultList[[as_label(paste0(f,"_value"))]] <- funcVal
  }
  return(resultList)
}
```

Now for some testing. We will perform three basic tests to start out. One where we call `getRMSE`. Another where we call `getMAE`. Last where we call both `getRMSE` and `getMAE`. We'll reset the seed and our response and prediction variables as well.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

wrapperFunc(func = list("getRMSE"),resp,pred)
wrapperFunc(func = list("getMAE"),resp,pred)
wrapperFunc(func = list("getMAE","getRMSE"),resp,pred)
```
Lets repeat this but replace two values with `NA_real_`. We will do this with and without specifying the handling of NA behavior.

```{r}
resp[31] <- NA_real_
resp[52] <- NA_real_

## No spec for NA

wrapperFunc(func = list("getRMSE"),resp,pred)
wrapperFunc(func = list("getMAE"),resp,pred)
wrapperFunc(func = list("getMAE","getRMSE"),resp,pred)

## Spec for NA

wrapperFunc(func = list("getRMSE"),resp,pred,na.rm=TRUE)
wrapperFunc(func = list("getMAE"),resp,pred,na.rm=TRUE)
wrapperFunc(func = list("getMAE","getRMSE"),resp,pred,na.rm=TRUE)
```
Now what about passing something that isn't two vectors? Lets pass a vector of string values of  in our response and prediction variables.

```{r}
wrapperFunc(responses=c("1","2","3"),predictions = c("4","5","6"))
```
## Task 3: Querying API Data

Using our API skills, we're going to construct an API call to pull some news data. I'm interested in sports data from the United States. We get a 200 Status ("Success") if ran correctly

**Note:** The user will have to store the API Key in an R.environ file for this to work.

```{r}
newsData <- httr::GET(url=paste0('https://newsapi.org/v2/top-headlines?country=us&category=sports&apiKey=',Sys.getenv("API_KEY")))
```

We need to parse the content to extract what is needed. We want to use our `pluck` function from the `purrr` library to extract the articles from our data. We are using a function to accomplish this where our raw API data is pulled in.

```{r}
rawToTibble <- function(rawData){
  articles <- fromJSON(rawToChar(rawData$content)) %>%
    pluck("articles")
  return(articles)
}

rawToTibble(newsData)
```
We want a user to be able to pass their own title/subject to search for (string), a time period to search from  and an API key.

By default, our topic will be "sports" retrieved from October 2024 onward. We see the call works with no parameters passed explicitly

```{r}
newsAPICall <- function(topic="sports",timePeriod='2024-10-01',apiKey=Sys.getenv("API_KEY")){
  url_string <- paste0('https://newsapi.org/v2/everything?q=',topic,'&from=',timePeriod,'&apiKey=',apiKey)
  rawCallData <- httr::GET(url=url_string)
  articles <- rawToTibble(rawCallData)
  return(articles)
}

newsAPICall()
```
I want to retrieve data on the topic Amazon and data on the topic Tesla since October 1, 2024.

```{r}
amazonArticles <- newsAPICall(topic="Amazon",timePeriod='2024-10-01')
teslaArticles <- newsAPICall(topic="Tesla",timePeriod='2024-10-01')

amazonArticles
teslaArticles
```
For our sources, we want to create a one-way contingency table for the source names. Lets do this for our Amazon article sources. We see most of our articles come from *Gizmodo.com*

```{r}
amazonSourceSummary <- amazonArticles %>%
  pluck("source") %>%
  group_by(name) %>%
  drop_na(name) %>%
  summarize(count=n())

amazonSourceSummary
```
That was interesting. Now for both our Amazon and Tesla data, we want to transform our data. We want to:
1. Turn `publishedAt` into a date column
2. Sort by the new `publishedAt` column
3. Difference in publish dates
4. Save our modifications as new data frames

```{r}
publishedTransform <- function(articleDf){
  
}
```

