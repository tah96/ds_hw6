---
title: "Hodge Podge"
format: html
editor: visual
---

## Libraries

Before starting anything, we will read in our necessary libraries

```{r}
library(tidyverse)
library(jsonlite)
library(lubridate)
```

## Task 1: Conceptual Questions

1.  **What is the purpose of lapply()? What is the equivalent in purrr?** The purpose of lapply is to "apply" a function to each element in a list. The result is a list of equal length containing result of the function applied. The equivalent of this in purrr is the map() function
2.  **Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = "kendall") on each element of the list. Write code to do this below! (I'm really trying to ask you how you specify method = "kendall" when calling lapply())** lapply(my_list, cor, method = "kendall")
3.  **What are two advantages of using purrr functions instead of the BaseR apply family?** Purrr functions are usually cleaner and more consistent than the BaseR apply. They also come with helper functions that work well within the tidyverse to improve usability.
4.  **What is a side-effect function?** A function that does more than return a result. Examples are print() or write_csv().
5.  **Why can you name a variable sd in a function and not cause any issues with sd outside the function?** Variables inside a function are encased in a temporary environment and only exist while the function is behind executed. Because of this localized behavior, it does not interfere with other environmental variables

## Task 2: Writing R Functions

To get some practice writing some advanced R functions using our new libraries, we will start by writing a function to compute Root Mean Square Error (RMSE).

We want to pass a vector of responses and predictions. We also want to give the user an option to pass additional arguments in our function that get passed to the mean function to instruct how to deal with NA values

```{r}
getRMSE <- function(responses,predictions,...){
  if (!is.vector(responses) | !is.vector(predictions)) {
    stop("Both your response and prediction inputs must be vectors")
  }
  meanError <- mean((responses-predictions)^2,...)
  squareMeanError <- sqrt(meanError)
  return(squareMeanError)
}
```

Lets create some response and prediction variables.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Using this data, lets tests or `getRMSE` function to make sure it works without error.

```{r}
getRMSE(responses = resp,predictions = pred)
```

We need replace two values in our response vector with `NA_real_` to ensure we can specify behavior to deal with these and not. Lets replaced the 31st and 52nd values with `NA_real_`

```{r}
resp[31] <- NA_real_
resp[52] <- NA_real_
```

Lets test the function specifying how to deal with these NAs and without specifying how to deal with these.

We see when no behavior is specified we get an error, but when we specify `na.rm=TRUE` our function will pass this to the localized mean function and remove NAs

```{r}
## No behavior specified
getRMSE(resp,pred)

## Behavior specified.
getRMSE(resp,pred,na.rm=TRUE)
```

In addition to RMSE, we want to look at MAE or the Mean Absolute Error. Lets create a function for this and follow similar behaviors to getRMSE

```{r}
getMAE <- function(responses,predictions,...){
  if (!is.vector(responses) | !is.vector(predictions)) {
    stop("Both your response and prediction inputs must be vectors")
  }
  absMeanError <- mean(abs(responses-predictions),...)
  return(absMeanError)
}
```

Reset our responses and predictions...

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Lets test the function. Success!

```{r}
getMAE(resp,pred)
```

We need replace two values in our response vector with `NA_real_` to ensure we can specify behavior to deal with these and not. Lets replaced the 31st and 52nd values with `NA_real_`

```{r}
resp[31] <- NA_real_
resp[52] <- NA_real_
```

Lets test the function specifying how to deal with these NAs and without specifying how to deal with these.

We see when no behavior is specified we get an error, but when we specify `na.rm=TRUE` our function will pass this to the localized mean function and remove NAs

```{r}
## No behavior specified
getMAE(resp,pred)

## Behavior specified.
getMAE(resp,pred,na.rm=TRUE)
```

Let's create a wrapper function that can be used to get either or both metrics returned with a single function call with appropriate names. We'll perform checks, default behaviors and flexibility features to allow for other metrics that aren't RMSE or MAE

The function should check that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, a message should print and the function should exit. â€¢ The function should return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.

```{r}
wrapperFunc <- function(func = list("getRMSE","getMAE"),responses,predictions,...){
  if ((!is.vector(responses) | !is.vector(predictions)) | 
      (!is.atomic(responses) | !is.atomic(predictions)) |
      (!is.numeric(responses) | !is.numeric(predictions))
      ){
    stop("Both your response and prediction inputs must be atomic numeric vectors")
  }
  resultList <- list()
  for(f in func){
    retrieveFunc <- get(f)
    funcVal <- retrieveFunc(responses,predictions,...)
    resultList[[as_label(paste0(f,"_value"))]] <- funcVal
  }
  return(resultList)
}
```

Now for some testing. We will perform three basic tests to start out. One where we call `getRMSE`. Another where we call `getMAE`. Last where we call both `getRMSE` and `getMAE`. We'll reset the seed and our response and prediction variables as well.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

wrapperFunc(func = list("getRMSE"),resp,pred)
wrapperFunc(func = list("getMAE"),resp,pred)
wrapperFunc(func = list("getMAE","getRMSE"),resp,pred)
```

Lets repeat this but replace two values with `NA_real_`. We will do this with and without specifying the handling of NA behavior.

```{r}
resp[31] <- NA_real_
resp[52] <- NA_real_

## No spec for NA

wrapperFunc(func = list("getRMSE"),resp,pred)
wrapperFunc(func = list("getMAE"),resp,pred)
wrapperFunc(func = list("getMAE","getRMSE"),resp,pred)

## Spec for NA

wrapperFunc(func = list("getRMSE"),resp,pred,na.rm=TRUE)
wrapperFunc(func = list("getMAE"),resp,pred,na.rm=TRUE)
wrapperFunc(func = list("getMAE","getRMSE"),resp,pred,na.rm=TRUE)
```

Now what about passing something that isn't two vectors? Lets pass a vector of string values of in our response and prediction variables.

```{r}
wrapperFunc(responses=c("1","2","3"),predictions = c("4","5","6"))
```

## Task 3: Querying API Data

Using our API skills, we're going to construct an API call to pull some news data. I'm interested in sports data from the United States. We get a 200 Status ("Success") if ran correctly

**Note:** The user will have to store the API Key in an R.environ file for this to work.

```{r}
newsData <- httr::GET(url=paste0('https://newsapi.org/v2/top-headlines?country=us&category=sports&apiKey=','2cce77c3fee5429693ef8fe6949ef84b'))
```

We need to parse the content to extract what is needed. We want to use our `pluck` function from the `purrr` library to extract the articles from our data. We are using a function to accomplish this where our raw API data is pulled in.

```{r}
rawToTibble <- function(rawData){
  articles <- fromJSON(rawToChar(rawData$content)) %>%
    pluck("articles")
  return(articles)
}

rawToTibble(newsData)
```

We want a user to be able to pass their own title/subject to search for (string), a time period to search from and an API key.

By default, our topic will be "sports" retrieved from October 2024 onward. We see the call works with no parameters passed explicitly

```{r}
newsAPICall <- function(topic="sports",timePeriod='2024-10-01',apiKey=Sys.getenv("API_KEY")){
  url_string <- paste0('https://newsapi.org/v2/everything?q=',topic,'&from=',timePeriod,'&apiKey=',apiKey)
  rawCallData <- httr::GET(url=url_string)
  articles <- rawToTibble(rawCallData)
  return(articles)
}
```

I want to retrieve data on the topic Amazon and data on the topic Tesla since October 1, 2024.

```{r}
amazonArticles <- newsAPICall(topic="Amazon",timePeriod='2024-10-01',apiKey="2cce77c3fee5429693ef8fe6949ef84b")
teslaArticles <- newsAPICall(topic="Tesla",timePeriod='2024-10-01',apiKey="2cce77c3fee5429693ef8fe6949ef84b")

amazonArticles
teslaArticles
```

For our sources, we want to create a one-way contingency table for the source names. Lets do this for our Amazon article sources. We see most of our articles come from *Gizmodo.com*

```{r}
amazonSourceSummary <- amazonArticles %>%
  pluck("source") %>%
  group_by(name) %>%
  drop_na(name) %>%
  summarize(count=n())

amazonSourceSummary
```

That was interesting. Now for both our Amazon and Tesla data, we want to transform our data. We want to: 1. Turn `publishedAt` into a date column 2. Sort by the new `publishedAt` column 3. Difference in publish dates 4. Save our modifications as new data frames

```{r}
publishedTransform <- function(articleDf){
  df <- articleDf %>%
    mutate(publishedAt = as_date(ymd_hms(publishedAt))) %>%
    arrange(desc(publishedAt)) %>%
    mutate(pub_diff = lag(publishedAt) - publishedAt)
  return(df)
}

amazonArticlesDates <- publishedTransform(amazonArticles)
teslaArticlesDates <- publishedTransform(teslaArticles)

amazonArticlesDates
teslaArticlesDates
```

With each of your resulting two data objects for Amazon and Tesla, we are going to isolate our `publishedAt` and `pub_diff` columns. We are then going to use the `map()` function form the `purrr` library to get the mean, standard deviation and median from each of these columns.

```{r}
dateSummary <- function(df){
  df <- df %>%
    select(c("publishedAt","pub_diff"))
  values <- map(df,\(x) list(
    "mean" = mean(x,na.rm = TRUE),
    "median" = median(x,na.rm=TRUE),
    "sd" = sd(x,na.rm=TRUE)
    )
  )
  return(values)
}
dateSummary(amazonArticlesDates)
dateSummary(teslaArticlesDates)
```
